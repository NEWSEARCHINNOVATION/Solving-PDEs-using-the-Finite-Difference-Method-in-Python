# -*- coding: utf-8 -*-
"""Self Project_Part 1_Haribalan S.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mWaoSQzLGkBg1jQ1H-ltJpZfkZYTQF43
"""

"""
Importing required libraries as below
numpy library is used inorder to perform trigonometric operations and also to use pi value
matplotlib library is used mainly to plot graphs
"""
import numpy as np
from matplotlib import pyplot as plt

"""
Initialization of variables are as follows
"""
IM = 41                                  #IM refers to number of computational nodes along x axis
JM = 81                                  #JM refers to number of computational nodes along y axis
L = 1                                    #L refers to the length of the 2D rectangular plate
H = 2                                    #H refers to the height of the 2D rectangular plate
dx = L/(IM-1)                            #Element length along element in x axis
dy = H/(JM-1)                            #Element length along element in y axis
B = dx/dy                                #Calculation of Beta (given in class as well as in the question document), here named as B
X = np.linspace(0, L, IM)                #X constitutes of distance of each node from origin along x axis used for exact solution calculation
Y = np.linspace(0, H, JM)                #Y constitutes of distance of each node from origin along y axis used for exact solution calculation
T_0 = np.zeros((IM, JM))                 #T_0 which is a 2D array defined to store initial temperature distribution (It is same as T_i,j at n = 0)
error = np.inf                           #Initializing error as a large finite number (tends to infinity)
T_0[:,0] = 250                           #Initializing Temperature as 250 along y=0
T_0[0,:], T_0[:,-1], T_0[-1,:] = 0, 0, 0 #Initializing temperature as zero along remaining boundaries
"""
The below three initialization (T_01, T_02, T_03) makes a copy of T_0 and
enters into each method, without changing the values within T_0
"""
T_01 = np.copy(T_0)
T_02 = np.copy(T_0)
T_03 = np.copy(T_0)
"""
The below comment fits for all three methods which are defined as functions below:
=> For every method, T is passed as an argument.
=> Within the function err(list to collect error values) and iter(list to collect no. of iterations)
   are initialized which thereby collect the respective data to plot convergence history
=> The loop starts with a while loop, which gets terminated when the if condition is true i.e., when error < 10^-3.
=> T_initial, a copy of initial temperature distribution is copied for computing (n+1)th time temperature distribution.
=> The first "for loop" increases iteration and moves along computational nodes in x-axis, similarly
   the second "for loop" increases iteration and moves along computational nodes in x-axis.
=> The only difference among the three functions are the equation T[i,j] (in class notation it is named as symbol 'phi'(ϕ),
   but here because of computing temperature, T is used) used for computation.
=> Once T[i,j] is computed, an absolute value (just magnitude without sign) of the error is calculated,
   which is then checked in if statement, whether convergence is attained or not. If not, the loop continues.
=> The error itself gets appended as log10(error) to plot for convergence history.
=> The error, no. of iterations get printed also they are returned along with computed 'T'.
"""
def Point_Jacobi(T):
  err1 = []
  iter1 = []
  iteration = 0
  while True:
    T_initial = np.array(T, copy=True)
    for i in range (1, IM-1):
      for j in range (1, JM-1):
        T[i,j] = (1/(2*(1 + B**2))*(T_initial[i+1,j] + T_initial[i-1,j] + B**2*(T_initial[i,j+1] + T_initial[i,j-1])))
    error =  np.sum(np.abs(T - T_initial))
    err1.append(np.log10(error))
    iteration += 1
    iter1.append(iteration)
    T_initial = T
    if error<10**-3:
      break
  print("Convergence history: \nPJ Method: Error = ",error,", No. of Iterations = ",iteration)
  return err1, iter1, T

def Point_Gauss_Seidel(T):
  err2 = []
  iter2 = []
  iteration = 0
  while True:
    T_initial = np.array(T, copy=True)
    for i in range (1, IM-1):
      for j in range (1, JM-1):
        T[i,j] = (1/(2*(1 + B**2))*(T_initial[i+1,j] + T[i-1,j] + B**2*(T_initial[i,j+1] + T[i,j-1])))
    error =  np.sum(np.abs(T - T_initial))
    err2.append(np.log10(error))
    iteration += 1
    iter2.append(iteration)
    T_initial = T
    if error<10**-3:
      break
  print("PGS Method: Error = ",error,", No. of Iterations = ",iteration)
  return err2, iter2, T
"""
In the case of PSOR method below, two more steps are added along with which are previously stated above.
'a' and 'w-optimum' are calculated as per given equations in question document. (It was mentioned that those are
obtained by solving the system of equations obtained from the discretized Laplace equation)
"""
def Point_Successive_Over_Relaxation(T):
  err3 = []
  iter3 = []
  iteration = 0
  a = (((np.cos(np.pi/(IM-1))) + B**2 *(np.cos(np.pi/(IM-1))))/(1 + B**2))**2
  w_opt = (2-2*np.sqrt(1-a))/a
  while True:
    T_initial = np.array(T, copy=True)
    for i in range (1, IM-1):
      for j in range (1, JM-1):
        T[i,j] = ((1-w_opt)*T_initial[i,j]) + (w_opt/(2*(1 + B**2))*(T_initial[i+1,j] + T[i-1,j] + (B**2)*(T_initial[i,j+1] + T[i,j-1])))
    error =  np.sum(np.abs(T - T_initial))
    err3.append(np.log10(error))
    iteration += 1
    iter3.append(iteration)
    T_initial = T
    if error<10**-3:
      break
  print("PSOR Method: Error = ",error,", No. of Iterations = ",iteration)
  return err3, iter3, T
"""
=> A seperate function is created to plot the contour.
=> As matplotlib was used for plotting, softwares like ParaView was not used.
=> T refers to the final temperature distribution, extent refers to physical dimension of the plot
=> origin = 'lower' refers to the origin is at lower left corner,
=> cmap refers to color map used in the contour.
=> Rest of syntax is general syntax for plotting, which applies to all of the below plots.
"""
def plotting_contour(T,method):
  plt.imshow(T.T, extent=[0, L, 0, H], origin='lower', cmap='inferno')
  plt.colorbar(label='Temperature (°C)')
  plt.xlabel('x')
  plt.ylabel('y')
  plt.title(f'Temperature Distribution ({method})')
  plt.show()
"""
The below function is to plot the convergence history, where the error (i.e. log10(Error)) of PJ, PGS
and PSOR are together plotted along y-axis with x-axis as number of iterations
"""
"""
e n,i n, T n, where n = 1,2,3 are used to store the return values from function
where, 1 refers to point jacobi function
        2 refers to point Gauss seidel function
        3 refers to point Successive over Relaxation
"""
e1,i1,T1 = Point_Jacobi(T_01)
e2,i2, T2 = Point_Gauss_Seidel(T_02)
e3, i3, T3 = Point_Successive_Over_Relaxation(T_03)
def plot_error():
  plt.plot(i1,e1, label="Point Jacobi", color='blue')
  plt.plot(i2,e2, label='Point Gauss Seidel', color='red')
  plt.plot(i3,e3, label='Point Successive Over Relaxation', color='orange')
  plt.xlabel('Number of Iterations')
  plt.ylabel('log10(ERROR)')
  plt.title('Convergence history')
  plt.legend()
  plt.show()
"""
The below function is to calculate the exact solution and plot comparison graph
in comparison with the numerical solutions obtained using  PJ, PGS and PSOR methods
"""
def plot_exact_soln():
  Temp_x = 0    #Temproary variable to store temperature value computing along y = 1.0 line
  Temp_y = 0    #Temproary variable to store temperature value computing along x = 0.5 line
  T_x = []      #List is initialized to collect Temp_x
  T_y = []      #List is initialized to collect Temp_y
  """
  For number of 'n' terms, professor instructed to take till 5, but here trying till 100
  """
  for x in X:
    for n in range (1,100):
      y = 1                   #Since computing along y = 1, it is set as constant
      Temp_x = Temp_x +((1-(-1)**n)/(n*np.pi))*(((np.sinh((n*np.pi*(H-y))/L))*np.sin((n*np.pi*x)/L))/(np.sinh((n*np.pi*H)/L)))
    T_x.append(500*Temp_x)    #Since the summation term is multiplied by 250*2, Temp_x is multiplied by 500
    Temp_x = 0                #Since to avoid overwriting of summation, the Temp_x is set to zero

  for y in Y:
    for n in range (1,100):
      x = 0.5                 #Since computing along x = 0.5, it is set as constant
      Temp_y = Temp_y +((1-(-1)**n)/(n*np.pi))*(((np.sinh((n*np.pi*(H-y))/L))*np.sin((n*np.pi*x)/L))/(np.sinh((n*np.pi*H)/L)))
    T_y.append(500*Temp_y)    #Since the summation term is multiplied by 250*2, Temp_y is multiplied by 500
    Temp_y = 0                #Since to avoid overwriting of summation, the Temp_y is set to zero

  plt.plot(X, T_x, label="Exact Solution", color="blue", marker = 'o')
  plt.plot(X, T1[:,41], label="Point Jacobi", color="red", marker = 's')
  plt.plot(X, T2[:,41], label="Point Seidel", color="orange", marker = 'd')
  plt.plot(X, T3[:,41], label="PSOR", color="black", marker = '^')
  plt.title('T Variation along y = 1 line')
  plt.xlabel('Length of plate (L)(x axis)')
  plt.ylabel('Temperature (°C)')
  plt.legend()
  plt.show()

  plt.plot(Y, T_y, label="Exact Solution", color="blue", marker = 'o')
  plt.plot(Y, T1[21,:], label="Point Jacobi", color="red", marker = 's')
  plt.plot(Y, T2[21,:], label="Point Seidel", color="orange", marker = 'd')
  plt.plot(Y, T3[21,:], label="PSOR", color="black", marker = '^')
  plt.title('T Variation along x = 0.5 line')
  plt.xlabel('Height of plate (H)(y axis)')
  plt.ylabel('Temperature (°C)')
  plt.legend()
  plt.show()

"""
A main function is defined as below, to run every function and to
get all results together as below
"""
def main():
  """
  Below statements, calls the functions to plot contour plot for
  Initial conditions, final temperature distribution for PJ, PGS and PSOR method
  """
  plotting_contour(T_0,"Initial conditions")
  plotting_contour(T1,"Point Jacobi")
  plotting_contour(T2,"Point Gauss Seidel")
  plotting_contour(T3,"Point Successive Over Relaxation")

  plot_error()        #To plot convergence history as log10(Error) Vs No. of Iterations
  plot_exact_soln()   #To plot variations of temperature T along the midline and comparing numerical solution with exact solution

main()                #Executing main function