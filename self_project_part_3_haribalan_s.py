# -*- coding: utf-8 -*-
"""Self Project_Part 3_Haribalan S.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oFkBbq_nyqnoy0Drh2WrxdYXeompCRiq
"""

"""
Importing required libraries as below
numpy library is used inorder to perform trigonometric operations and also to use pi value
matplotlib library is used mainly to plot graphs
"""
import numpy as np
from matplotlib import pyplot as plt

N = 203                             #Initializing total number of grid points inclusive of ghost points
x = np.linspace(0,1,N)              #Initializing x-location of every grid point
x_exact = np.linspace(0, 1, 101)    #Intializing x-location of every point to plot as per exact solution
nu = 0.5                            #CFL number, since for stability it was mentioned to select a value less than or equal to 1
dx = 1/(N-1)                        #Distance between two grid points (or) element size
u_initial = 0                       #Intial velocity
T_initial = 300                     #Initial Temperature
P_upstream = 5*101325               #Pressure upstream of diaphragm, coverted to Pascal (1 atm = 101325 Pa)
P_downstream = 1*101325             #Pressure downstream of diaphragm, coverted to Pascal (1 atm = 101325 Pa)
t = 0.75 * 10**-3                   #Specified time for observation of results once diaphragm ruptures
u, P = np.zeros(N), np.zeros(N)     #Initializing array to store velocity (all zero) and pressure
T = np.full((N),300)                #Initializing Temperature array and storing all elements as 300
"""
The below for loop is to store Pressure value along every grid point.
Till diaphragm, i.e., till x = 0.5 the pressure equals 5 atm.
Downstream of diaphragm, the pressure equals 1 atm.
"""
for i in range (N):
  if i*dx<0.5:
    P[i] = P_upstream
  else:
    P[i] = P_downstream

gamma = 1.4                         #ratio of specific heat
R =  287                            #Specific gas constant
"""
The below equations are from basic gas dynamics and whichever taught in class,
which will be used in the below function
"""
a = np.sqrt(gamma*R*T)              #Speed of sound
M = u/a                             #Mach number
rho = P/(R*T)                       #Density
rho_u = rho*u                       #Product of density and velocity
E = (P/(gamma-1)) + (0.5*rho*u**2)  #Energy (Equation given in class)
F_PVL = np.zeros((N,3))             #F_PVL refers to Positive Van Leer flux
F_NVL = np.zeros((N,3))             #F_NVL refers to Negative Van Leer flux

"""
The belox function is to compute Van Leer fluxes and applying Upwind scheme
to compute the variables of U
"""
def Van_Leer_Method():
  t = 0.75 * 10**-3                #Specified time for observation of results once diaphragm ruptures
  while t>=0:                      #When time becomes zero
    lamda_max = max(abs(u)+abs(a)) #Computing maximum eigen value to find time step
    print(T)
    dt = (nu*dx)/lamda_max         #Time step computed in terms of maximum eigen value
    for i in range (N):            #Computing fluxes including ghost points
      """
      The below if case checks for Mach number less than or equal to -1,
      if so, the positive and negative fluxes will be computed accordingly.
      Similarly for every elif cases, if the Mach number is within the
      specified range, then the positive and negative fluxes will be computed
      as per given in the assignment document under the title
      Split Fluxes for van Leer Method.
      """
      if M[i] <= -1:
        F_PVL[i,:] = 0

        F_NVL[i,0] = rho[i]*u[i]
        F_NVL[i,1] = (rho[i]*u[i]**2) + P[i]
        F_NVL[i,2] = (E[i] + P[i])*u[i]

      elif M[i] < 1 and M[i] > -1:
        F_PVL[i,0] = 0.25*rho[i]*a[i]*(M[i]+1)**2
        F_PVL[i,1] = (0.25*rho[i]*a[i]*(M[i]+1)**2)*((2*a[i]/gamma)*(1+(((gamma-1)/2)*M[i])))
        F_PVL[i,2] = (0.25*rho[i]*a[i]*(M[i]+1)**2)*((2*a[i]**2/(gamma**2 - 1))*(1+((gamma-1)/2)*M[i])**2)

        F_NVL[i,0] = (rho[i]*u[i]) - F_PVL[i,0]
        F_NVL[i,1] = (rho[i]*u[i]**2 + P[i]) - F_PVL[i,1]
        F_NVL[i,2] = ((E[i] + P[i])*u[i]) - F_PVL[i,2]

      elif M[i] > 1: #NP
        F_PVL[i,0] = rho[i]*u[i]
        F_PVL[i,1] =  (rho[i]*u[i]**2) + P[i]
        F_PVL[i,2] = (E[i] + P[i])*u[i]

        F_NVL[i,:] = 0
    """
    Once computing of fluxes are done, the variables in U are computed as per
    eqaution 2 specified in the assignment document as below
    """

    for i in range (1,N-1):
      rho[i] = rho[i] - (dt/dx)*(F_PVL[i,0] - F_PVL[i-1,0]) - (dt/dx)*(F_NVL[i+1,0] - F_NVL[i,0])
      rho_u[i] = rho_u[i] - (dt/dx)*(F_PVL[i,1] - F_PVL[i-1,1]) - (dt/dx)*(F_NVL[i+1,1] - F_NVL[i,1])
      E[i] = E[i] - (dt/dx)*(F_PVL[i,2] - F_PVL[i-1,2]) - (dt/dx)*(F_NVL[i+1,2] - F_NVL[i,2])
      """
      Once variables are computed by means of fluxes, the updation of variables takes place as below
      """
      u[i] = rho_u[i]/rho[i]                          #Velocity
      P[i] = (E[i] - (0.5*rho[i]*u[i]**2))*(gamma-1)  #Pressure
      T[i] = P[i]/(rho[i]*R)                          #Temperature
      a[i] = np.sqrt(gamma*R*T[i])                    #Speed of Sound
      M[i] = u[i]/a[i]                                #Mach number
    t = t-dt                                          #the time step is subtracted from the end time, for every iteration, taking it towards zero
  #print(F_PVL)
  #print(F_NVL)
  return P, T, u, M, rho

"""
The below list of exact solutions are extracted from excel sheet
(exact-solution-shock-tube.xlsx). Only the exact solution Mach number is computed
as below using velocity and temperature data
"""
def Exact_Solution():

  p_exact = [506625,506625,506625,506625,506625,506625,506625,506625,506625,506625,
            506625,506625,506625,506625,506625,506625,506625,506625,506625,506625,
            506625,506625,506625,506625,505737,483503,462112,441537,421753,402733,
            384453,366890,350018,333816,318261,303332,289006,275265,262088,249455,
            237347,225747,215607,215607,215607,215607,215607,215607,215607,215607,
            215607,215607,215607,215607,215607,215607,215607,215607,215607,215607,
            215607,215607,215607,215607,215607,215607,215607,215607,215607,215607,
            215607,215607,215607,215607,215607,215607,215607,215607,215607,215607,
            215607,215607,215607,215607,215607,215607,215607,101325,101325,101325,
            101325,101325,101325,101325,101325,101325,101325,101325,101325,101325,101325]

  rho_exact = [5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,
              5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,
              5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,5.88415,
              5.87678,5.69105,5.51005,5.33368,5.16185,4.99449,4.83149,4.67278,
              4.51827,4.36787,4.2215,4.07908,3.94054,3.80578,3.67474,3.54733,
              3.42348,3.30311,3.19644,3.19644,3.19644,3.19644,3.19644,3.19644,
              3.19644,3.19644,3.19644,3.19644,3.19644,3.19644,3.19644,3.19644,
              3.19644,3.19644,3.19644,3.19644,3.19644,3.19644,3.19644,3.19644,
              3.19644,1.99335,1.99335,1.99335,1.99335,1.99335,1.99335,1.99335,
              1.99335,1.99335,1.99335,1.99335,1.99335,1.99335,1.99335,1.99335,
              1.99335,1.99335,1.99335,1.99335,1.99335,1.99335,1.99335,1.17683,
              1.17683,1.17683,1.17683,1.17683,1.17683,1.17683,1.17683,1.17683,
              1.17683,1.17683,1.17683,1.17683,1.17683]

  T_exact = [300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,300,
            300,300,300,300,300,300,300,299.85,296.023,292.22,288.442,284.689,
            280.96,277.256,273.576,269.921,266.291,262.685,259.103,255.547,252.014,
            248.507,245.024,241.565,238.132,235.025,235.025,235.025,235.025,235.025,
            235.025,235.025,235.025,235.025,235.025,235.025,235.025,235.025,235.025,
            235.025,235.025,235.025,235.025,235.025,235.025,235.025,235.025,235.025,
            376.875,376.875,376.875,376.875,376.875,376.875,376.875,376.875,376.875,
            376.875,376.875,376.875,376.875,376.875,376.875,376.875,376.875,376.875,
            376.875,376.875,376.875,376.875,300,300,300,300,300,300,300,300,300,300,
            300,300,300,300]

  u_exact = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.435036,11.5461,22.6573,
            33.7684,44.8795,55.9906,67.1017,78.2128,89.3239,100.435,111.546,122.657,
            133.768,144.879,155.991,167.102,178.213,189.324,199.445,199.445,199.445,
            199.445,199.445,199.445,199.445,199.445,199.445,199.445,199.445,199.445,
            199.445,199.445,199.445,199.445,199.445,199.445,199.445,199.445,199.445,
            199.445,199.445,199.445,199.445,199.445,199.445,199.445,199.445,199.445,
            199.445,199.445,199.445,199.445,199.445,199.445,199.445,199.445,199.445,
            199.445,199.445,199.445,199.445,199.445,199.445,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

  M_exact = []
  for i in range (len(x_exact)):
    M_exact.append(u_exact[i]/np.sqrt(gamma*R*T_exact[i]))
  return p_exact, T_exact, u_exact, M_exact, rho_exact

"""
The below function is to plot numerical results along with the exact solution
shared to visualize it comparatively
"""
def plot_results(Numerical_result, Analytical_result, Title, axis_title):
    plt.plot(x, Numerical_result, color='blue', linestyle='--', label="Numerical solution")
    plt.plot(x_exact, Analytical_result, color='darkorange', linestyle='-.', label="Exact solution")
    plt.title(Title + " - Numerical Vs Exact")
    plt.xlabel("x")
    plt.ylabel(axis_title)
    plt.legend()
    plt.show()

Numerical_result = np.array(5)      #Initializing an array to get numerical results to plot
analytical_result = np.array(5)     #Initializing an array to get exact results to plot
Numerical_result = Van_Leer_Method()
Analytical_result = Exact_Solution()

plot_results(Numerical_result[0], Analytical_result[0],"Pressure (P)", "Pressure (Pa)")

plot_results(Numerical_result[1], Analytical_result[1],"Temperature (T)", "Temperature (K)")

plot_results(Numerical_result[2], Analytical_result[2],"Velocity (u)", "Velocity (m/s)")

plot_results(Numerical_result[3], Analytical_result[3],"Mach Number (M)", "Mach Number")

plot_results(Numerical_result[4], Analytical_result[4],"Density (ρ)", "Density (kg/m^3)")